// Copyright 2023 Peter Hebert. Licensed under the MIT license.

package internal

import "testing"

// cspell:ignore abca

func TestSerializedTrie_Lookup(t *testing.T) {
	// this SerializedTrie was generated by commented-out lines in gen/trie_test.go
	nanoTrie := serializedTrie{3, 0x861, 0x362, 0x563, 0x102, 0x761, 0xe62, 0x501, 0xb63}
	nanoWords := []string{"a", "b", "c", "aa", "ab", "abc"}   // all words in the trie
	otherWords := []string{"", "d", "ac", "bd", "ca", "abca"} // some words not in the trie

	// test all words in the trie
	for token, word := range nanoWords {
		t.Run("nanoTrie.Lookup('"+word+"')", func(t *testing.T) {
			if got := nanoTrie.Lookup([]byte(word)); got != token {
				t.Errorf("SerializedTrie.Lookup(%q) = %v, want %v", word, got, token)
			}
		})
	}

	// also test some words _not_ in the trie
	for _, word := range otherWords {
		t.Run("nanoTrie.Lookup('"+word+"')", func(t *testing.T) {
			if got := nanoTrie.Lookup([]byte(word)); got != -1 {
				t.Errorf("SerializedTrie.Lookup(%q) = %v, want -1", word, got)
			}
		})
	}

	// also test baby tokenizer's trie since its root node is 256-ary
	// this test uses TrieLookup() for test coverage completeness
	babyTrie := tokenTrie // tokenTrie and tokenList from baby_test.go
	for token, word := range tokenList {
		t.Run("babyTrie.Lookup('"+word+"')", func(t *testing.T) {
			if got := TrieLookup(babyTrie, []byte(word)); got != token {
				t.Errorf("SerializedTrie.Lookup(%q) = %v, want %v", word, got, token)
			}
		})
	}
}
